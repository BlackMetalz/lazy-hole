# Day 2: Feb 4, 2026

### Story 1.2 (1 point)

Add cobra CLI for lazy-hole with --help and --version, it is copy-able from ChgK8sCtx project xD

### Story 1.3 (1 point)

I noticed there is `Fprintln(os.Stderr, err)` in `rootCmd.go`
I start to ask why, and did little research about it, what is different between it and `fmt.Errorf()` in day1.md

So quick report:

`fmt.Errorf()`:
- Purpose: create error to return
- Return: `error` object
- Usage: Inside function

`fmt.Fprintln(os.Stderr, err)`:
- Purpose: print error to stderr
- Return: written bytes
- Usage: In main function to print error. With this define, we can redirect error to file or pipe to another command: `./app > output.txt 2> error.txt` like this. ==> go LFCS course, IO redirection part bro!


Result for story 1.3 after we add new flag, it is just show new flag in command help. LOL

Before
```bash
kienlt@Luongs-MacBook-Pro lazy-hole % go run . --help
lazy-hole - A CLI/TUI tool to simulate network failures for testing distributed systems.

Usage:
  lazy-hole [flags]

Flags:
  -h, --help      help for lazy-hole
  -v, --version   version for lazy-hole
```

After
```bash
kienlt@Luongs-MacBook-Pro lazy-hole % go run . --help
lazy-hole - A CLI/TUI tool to simulate network failures for testing distributed systems.

Usage:
  lazy-hole [flags]

Flags:
  -c, --config string   Path to config file (default "sample/hosts.yaml")
  -h, --help            help for lazy-hole
  -v, --version         version for lazy-hole
  ```
```

And with default config:
```bash
go run .
invalid IP address: 10.0.0.999
exit status 1
```

Some other cases
```bash
# ====== NON EXISTS =======
go run . -c /nonexistent.yaml
failed to read config file: open /nonexistent.yaml: no such file or directory
exit status 1
# ========= Short flag ======
go run . -c sample/hosts.yaml
invalid IP address: 10.0.0.999
exit status 1
# ========= Full flag ======
go run . --config sample/hosts.yaml
invalid IP address: 10.0.0.999
exit status 1
```

## Epic 2 ##

### Story 2.1 SSH connection to single host (3 points)
I think this is the most interesting part, ssh in fucking Go.
Goal: Using ssh lib to connect to single host, run remote command!

Package: `golang.org/x/crypto/ssh`

Create new file `ssh.go`
Gonna support only public key auth (default ~/.ssh/id_rsa or ed25519 xD) and host key verification will be skipped!

Whole SSH code is generated by Gemini. I only ask it to implement based my requirements. Only 1 host tested and it works! xD

```bash
go run . -c sample/live.yaml
lazy-hole v0.1.0
Loaded 1 hosts from sample/live.yaml
Successfully connected to mysql-node-1
```

There is 1 thing need to be notice, that is expand `~`
Because we often defined in field ssh_key: `~/.ssh/id_rsa`, right?
So we need to handle it as well, because this shit wont work: `os.ReadFile("~/.ssh/id_ed25519")`

Ok. Tested with multiple host working well so far

```bash
go run . -c sample/live.yaml
lazy-hole v0.1.0
Loaded 2 hosts from sample/live.yaml
Successfully connected to mysql-node-1
Failed to connect to mysql-node-2 via port 222: failed to connect to mysql-node-2: dial tcp 1.1.1.1:222: i/o timeout
```

Story 2.1 is finished. Tomorrow will be goroutines for concurrency!